// Generated by CoffeeScript 1.9.3

/*
 * * tiler
 * * https://github.com/brewster1134/tiler
 * *
 * * @version 1.0.4
 * * @author Ryan Brewster
 * * Copyright (c) 2014
 * * Licensed under the MIT license.
 */

(function() {
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      return define(['jquery', 'widget', 'effect'], function($) {
        return factory($);
      });
    } else {
      return factory(jQuery);
    }
  })(this, function($) {
    return $.widget('ui.tiler', {
      widgetEventPrefix: 'tiler',
      options: {
        isReversible: true
      },
      _create: function() {
        return this.currentTileIndex = null;
      },
      _init: function() {
        this.$tiles = $('.tiler-tile', this.element).not(this.element.find('.tiler-viewport .tiler-tile'));
        this._setupTiles();
        return this._setupLinks();
      },
      refresh: function() {
        var ref;
        this._init();
        this.element.trigger('tiler.refresh');
        return (ref = this.$enterTile) != null ? ref.trigger('tiler.refresh') : void 0;
      },
      goTo: function(tile, animation) {
        var $tile, tileIndex;
        if (animation == null) {
          animation = true;
        }
        $tile = typeof tile === 'string' ? this.$tiles.filter("#" + tile) : (tile != null ? tile.jquery : void 0) ? tile != null ? tile.jquery : void 0 : tile.nodeType ? $(tile) : this.$tiles.eq(tile - 1);
        tileIndex = this.$tiles.index($tile);
        if (!$tile.length || this.currentTileIndex === tileIndex) {
          return;
        }
        this.$enterTile = $tile;
        this.$exitTile = this.$tiles.eq(this.currentTileIndex);
        this._transitionCss(this._getAnimationClass(animation));
        this.element.trigger('tiler.goto', {
          enterTile: this.$enterTile,
          exitTile: this.$exitTile
        });
        this.$enterTile.trigger('tiler.enter');
        this.$exitTile.trigger('tiler.exit');
        this.currentTileIndex = tileIndex;
        this.element.attr('data-tiler-active-tile', this.$enterTile.attr('id'));
        return this.$enterTile;
      },
      _getAnimationClass: function(animation) {
        if (typeof animation === 'string') {
          return animation;
        }
        if (animation) {
          return this.$enterTile.data('tiler-animation') || this.element.data('tiler-animation') || '';
        } else {
          return '';
        }
      },
      _transitionCss: function(animationClass) {
        var enterStartClass, enterTileIndex, exitStartClass, otherTileClass, reverseClass;
        enterTileIndex = this.$tiles.index(this.$enterTile);
        reverseClass = this.options.isReversible && !this._isNavigatingForward(enterTileIndex) ? 'reverse' : '';
        this.element.addClass('animation-disabled');
        enterStartClass = "tiler-tile " + animationClass + " active enter " + reverseClass + " start";
        exitStartClass = "tiler-tile " + animationClass + " previous exit " + reverseClass + " start";
        otherTileClass = 'tiler-tile';
        this.$enterTile.attr('class', enterStartClass);
        this.$exitTile.attr('class', exitStartClass);
        this.$tiles.not(this.$enterTile).not(this.$exitTile).attr('class', otherTileClass);
        return setTimeout((function(_this) {
          return function() {
            _this.element.removeClass('animation-disabled');
            return _this.$enterTile.add(_this.$exitTile).switchClass('start', 'end');
          };
        })(this), 10);
      },
      _setupLinks: function() {
        return $('[data-tiler-link]').each(function() {
          var tile, tileId, tileIds;
          tileIds = $(this).data('tiler-link').split(':').reverse();
          tileId = tileIds[0];
          tile = tileIds[1] ? $(".tiler-tile#" + tileId, "#" + tileIds[1]) : $(".tiler-tile#" + tileId);
          if (!tile.length) {
            return;
          }
          return $.extend($(this).data(), tile.data());
        });
      },
      _setupTiles: function() {
        var self, tileHeights, tileWidths;
        self = this;
        tileWidths = [this.element.outerWidth()];
        tileHeights = [this.element.outerHeight()];
        this.$tiles.css({
          width: '',
          height: ''
        });
        this.$tiles.each(function() {
          tileWidths.push($(this).outerWidth());
          tileHeights.push($(this).outerHeight());
          return $(this).attr('data-tiler-viewport-id', self.element.attr('id'));
        });
        return this.element.add(this.$tiles).css({
          width: Math.max.apply(Math, tileWidths),
          height: Math.max.apply(Math, tileHeights)
        });
      },
      _isNavigatingForward: function(enterTileIndex) {
        return enterTileIndex > this.currentTileIndex;
      }
    });
  });

}).call(this);
